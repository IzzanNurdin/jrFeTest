{"ast":null,"code":"import _regeneratorRuntime from \"E:\\\\IzzanNurdin\\\\Job\\\\Tests\\\\Kata\\\\jr-fe-test\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\n\nvar _marked =\n/*#__PURE__*/\n_regeneratorRuntime.mark(handleFetch),\n    _marked2 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(watchFetchRequest),\n    _marked3 =\n/*#__PURE__*/\n_regeneratorRuntime.mark(heroesSaga);\n\nimport { all, call, fork, put, takeEvery } from \"redux-saga/effects\";\nimport { HeroesActionTypes } from \"./types\";\nimport { fetchError } from \"./actions\";\nimport { callApi } from \"../../utils/api\";\nvar API_ENDPOINT = process.env.REACT_APP_API_ENDPOINT || \"https://api.opendota.com\";\n\nfunction handleFetch() {\n  var res;\n  return _regeneratorRuntime.wrap(function handleFetch$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return call(callApi, \"get\", API_ENDPOINT, \"/api/heroStats\");\n\n        case 3:\n          res = _context.sent;\n\n          if (!res.error) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 7;\n          return put(fetchError(res.error));\n\n        case 7:\n          _context.next = 9;\n          break;\n\n        case 9:\n          _context.next = 20;\n          break;\n\n        case 11:\n          _context.prev = 11;\n          _context.t0 = _context[\"catch\"](0);\n\n          if (!(_context.t0 instanceof Error)) {\n            _context.next = 18;\n            break;\n          }\n\n          _context.next = 16;\n          return put(fetchError(_context.t0.stack));\n\n        case 16:\n          _context.next = 20;\n          break;\n\n        case 18:\n          _context.next = 20;\n          return put(fetchError(\"An unknown error occured.\"));\n\n        case 20:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, this, [[0, 11]]);\n} // This is our watcher function. We use `take*()` functions to watch Redux for a specific action\n// type, and run our saga, for example the `handleFetch()` saga above.\n\n\nfunction watchFetchRequest() {\n  return _regeneratorRuntime.wrap(function watchFetchRequest$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return takeEvery(HeroesActionTypes.FETCH_REQUEST, handleFetch);\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, this);\n} // We can also use `fork()` here to split our saga into multiple watchers.\n\n\nfunction heroesSaga() {\n  return _regeneratorRuntime.wrap(function heroesSaga$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return all([fork(watchFetchRequest)]);\n\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3, this);\n}\n\nexport default heroesSaga;","map":{"version":3,"sources":["E:\\IzzanNurdin\\Job\\Tests\\Kata\\jr-fe-test\\src\\stores\\heroes\\sagas.ts"],"names":["handleFetch","watchFetchRequest","heroesSaga","all","call","fork","put","takeEvery","HeroesActionTypes","fetchError","callApi","API_ENDPOINT","process","env","REACT_APP_API_ENDPOINT","res","error","Error","stack","FETCH_REQUEST"],"mappings":";;;;yBAQUA,W;;;yBAqBAC,iB;;;yBAKAC,U;;AAlCV,SAASC,GAAT,EAAcC,IAAd,EAAoBC,IAApB,EAA0BC,GAA1B,EAA+BC,SAA/B,QAAgD,oBAAhD;AACA,SAASC,iBAAT,QAAkC,SAAlC;AACA,SAASC,UAAT,QAAyC,WAAzC;AACA,SAASC,OAAT,QAAwB,iBAAxB;AAEA,IAAMC,YAAY,GAChBC,OAAO,CAACC,GAAR,CAAYC,sBAAZ,IAAsC,0BADxC;;AAGA,SAAUd,WAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGgB,iBAAMI,IAAI,CAACM,OAAD,EAAU,KAAV,EAAiBC,YAAjB,EAA+B,gBAA/B,CAAV;;AAHhB;AAGUI,UAAAA,GAHV;;AAAA,eAKQA,GAAG,CAACC,KALZ;AAAA;AAAA;AAAA;;AAAA;AAMM,iBAAMV,GAAG,CAACG,UAAU,CAACM,GAAG,CAACC,KAAL,CAAX,CAAT;;AANN;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,gBAWQ,uBAAeC,KAXvB;AAAA;AAAA;AAAA;;AAAA;AAYM,iBAAMX,GAAG,CAACG,UAAU,CAAC,YAAIS,KAAL,CAAX,CAAT;;AAZN;AAAA;AAAA;;AAAA;AAAA;AAcM,iBAAMZ,GAAG,CAACG,UAAU,CAAC,2BAAD,CAAX,CAAT;;AAdN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,C,CAmBA;AACA;;;AACA,SAAUR,iBAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,iBAAMM,SAAS,CAACC,iBAAiB,CAACW,aAAnB,EAAkCnB,WAAlC,CAAf;;AADF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,C,CAIA;;;AACA,SAAUE,UAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,iBAAMC,GAAG,CAAC,CAACE,IAAI,CAACJ,iBAAD,CAAL,CAAD,CAAT;;AADF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA,eAAeC,UAAf","sourcesContent":["import { all, call, fork, put, takeEvery } from \"redux-saga/effects\";\r\nimport { HeroesActionTypes } from \"./types\";\r\nimport { fetchError, fetchSuccess } from \"./actions\";\r\nimport { callApi } from \"../../utils/api\";\r\n\r\nconst API_ENDPOINT =\r\n  process.env.REACT_APP_API_ENDPOINT || \"https://api.opendota.com\";\r\n\r\nfunction* handleFetch() {\r\n  try {\r\n    // To call async functions, use redux-saga's `call()`.\r\n    const res = yield call(callApi, \"get\", API_ENDPOINT, \"/api/heroStats\");\r\n\r\n    if (res.error) {\r\n      yield put(fetchError(res.error));\r\n    } else {\r\n      // yield put(fetchSuccess(res));\r\n    }\r\n  } catch (err) {\r\n    if (err instanceof Error) {\r\n      yield put(fetchError(err.stack!));\r\n    } else {\r\n      yield put(fetchError(\"An unknown error occured.\"));\r\n    }\r\n  }\r\n}\r\n\r\n// This is our watcher function. We use `take*()` functions to watch Redux for a specific action\r\n// type, and run our saga, for example the `handleFetch()` saga above.\r\nfunction* watchFetchRequest() {\r\n  yield takeEvery(HeroesActionTypes.FETCH_REQUEST, handleFetch);\r\n}\r\n\r\n// We can also use `fork()` here to split our saga into multiple watchers.\r\nfunction* heroesSaga() {\r\n  yield all([fork(watchFetchRequest)]);\r\n}\r\n\r\nexport default heroesSaga;\r\n"]},"metadata":{},"sourceType":"module"}